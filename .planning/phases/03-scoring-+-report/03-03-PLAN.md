---
phase: 03-scoring-+-report
plan: 03
type: execute
wave: 2
depends_on:
  - 03-01
  - 03-02
files_modified:
  - src/scoring/engine/scoreCalculator.ts
  - src/scoring/engine/scoreEngine.ts
  - src/scoring/recommendations/recommendationEngine.ts
  - src/scoring/recommendations/ladderOptimizer.ts
autonomous: true

must_haves:
  truths:
    - "Score engine takes AnalysisContext + policy and returns ScoreResult"
    - "Score calculator aggregates rule scores using policy weights"
    - "Recommendation engine consolidates recommendations from all rules"
    - "Ladder optimizer generates improved ladder based on recommendations"
  artifacts:
    - path: "src/scoring/engine/scoreCalculator.ts"
      provides: "Weighted score aggregation logic"
      exports: ["calculateOverallScore", "calculateCategoryScores"]
    - path: "src/scoring/engine/scoreEngine.ts"
      provides: "Main scoring orchestrator"
      exports: ["runScoring"]
    - path: "src/scoring/recommendations/recommendationEngine.ts"
      provides: "Recommendation consolidation and deduplication"
      exports: ["consolidateRecommendations"]
    - path: "src/scoring/recommendations/ladderOptimizer.ts"
      provides: "Ladder optimization based on recommendations"
      exports: ["generateOptimizedLadder"]
  key_links:
    - from: "src/scoring/engine/scoreEngine.ts"
      to: "src/scoring/rules/index.ts"
      via: "getRuleById calls"
    - from: "src/scoring/engine/scoreEngine.ts"
      to: "src/scoring/policies/policyRegistry.ts"
      via: "policy lookup"
    - from: "src/scoring/engine/scoreEngine.ts"
      to: "src/scoring/engine/scoreCalculator.ts"
      via: "score aggregation"
    - from: "src/scoring/engine/scoreEngine.ts"
      to: "src/scoring/recommendations/recommendationEngine.ts"
      via: "recommendation consolidation"
---

<objective>
Build the scoring engine and recommendation system that orchestrates rules, calculates weighted scores, and generates optimized ladder recommendations.

Purpose: Create the core engine that runs all enabled rules for a selected policy, aggregates scores using policy weights, consolidates recommendations, and produces a complete ScoreResult with an optimized ladder suggestion.

Output: Working scoring engine with score calculator, recommendation consolidation, and ladder optimization.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scoring-+-report/03-RESEARCH.md
@.planning/phases/03-01-SUMMARY.md
@.planning/phases/03-02-SUMMARY.md
@src/types/scoring.ts
@src/scoring/rules/index.ts
@src/scoring/policies/policyRegistry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build score calculator and scoring engine</name>
  <files>
    src/scoring/engine/scoreCalculator.ts
    src/scoring/engine/scoreEngine.ts
  </files>
  <action>
Create the scoring engine components:

**src/scoring/engine/scoreCalculator.ts:**
Export two functions:

1. `calculateCategoryScores(ruleResults: RuleResult[], policy: ScoringPolicy): CategoryScore[]`
   - Group rule results by category (ladder, codec, segment, metadata)
   - For each category, calculate weighted average score
   - Only include enabled rules from policy
   - Return array of CategoryScore with score, maxScore, rules[]

2. `calculateOverallScore(categories: CategoryScore[]): number`
   - Calculate weighted average of category scores
   - Use policy weights to determine contribution
   - Return rounded integer 0-100

**src/scoring/engine/scoreEngine.ts:**
Export main function:

```typescript
export function runScoring(
  context: AnalysisContext,
  policyId: string
): ScoreResult
```

Implementation:
1. Look up policy via getPolicyById(policyId), throw if not found
2. Get all enabled rules from policy (filter by enabled: true)
3. For each enabled rule:
   - Get rule implementation via getRuleById(ruleId)
   - Call rule.check(context) with policy params if provided
   - Collect RuleResult
4. Calculate category scores via calculateCategoryScores
5. Calculate overall score via calculateOverallScore
6. Consolidate all warnings from rule results
7. Consolidate all recommendations
8. Generate optimized ladder (placeholder for now, full implementation in Task 2)
9. Return ScoreResult with:
   - overall score
   - categories breakdown
   - warnings array
   - recommendations array
   - originalLadder (from context)
   - recommendedLadder (optimized)

Import types from `../../types/scoring`, rules from `../rules`, policies from `../policies`.
  </action>
  <verify>npm run build compiles; console.log(runScoring(mockContext, 'generic')) returns valid ScoreResult</verify>
  <done>Score engine runs all rules, calculates weighted scores, returns complete ScoreResult</done>
</task>

<task type="auto">
  <name>Task 2: Build recommendation engine and ladder optimizer</name>
  <files>
    src/scoring/recommendations/recommendationEngine.ts
    src/scoring/recommendations/ladderOptimizer.ts
  </files>
  <action>
Create recommendation consolidation and ladder optimization:

**src/scoring/recommendations/recommendationEngine.ts:**
Export function:

```typescript
export function consolidateRecommendations(
  recommendations: Recommendation[]
): Recommendation[]
```

Implementation:
1. Deduplicate recommendations by id (keep highest severity if duplicates)
2. Sort by severity: critical first, then warning, then suggestion
3. Group by type (add_variant, remove_variant, modify_variant, general)
4. Return consolidated array

Add helper:
```typescript
export function mergeSimilarRecommendations(
  recs: Recommendation[]
): Recommendation[]
```
- Detect recommendations targeting same variant index
- Merge modify_variant recommendations for same variant

**src/scoring/recommendations/ladderOptimizer.ts:**
Export function:

```typescript
export function generateOptimizedLadder(
  originalLadder: LadderResult,
  recommendations: Recommendation[]
): LadderResult
```

Implementation:
1. Start with deep copy of original ladder
2. Apply recommendations in order:
   - `add_variant`: Insert new variant at appropriate position (sorted by bitrate)
   - `remove_variant`: Remove variant at specified index
   - `modify_variant`: Update variant properties (bitrate, resolution, codecs)
3. Ensure ladder remains valid after modifications:
   - Sort by bitrate descending after changes
   - Remove duplicates
   - Ensure at least one variant remains
4. Return optimized ladder

Add helper:
```typescript
function applyVariantChange(
  variant: LadderVariant,
  change: Partial<LadderVariant>
): LadderVariant
```

Import from `../../types/analysis` and `../../types/scoring`.
  </action>
  <verify>npm run build compiles; ladder optimizer produces valid LadderResult from recommendations</verify>
  <done>Recommendation consolidation deduplicates and sorts; ladder optimizer applies changes correctly</done>
</task>

</tasks>

<verification>
- [ ] Score calculator correctly weights rule scores by policy
- [ ] Score engine runs all enabled rules and aggregates results
- [ ] Recommendation engine deduplicates and sorts by severity
- [ ] Ladder optimizer applies add/remove/modify recommendations
- [ ] ScoreResult contains complete breakdown, warnings, recommendations, both ladders
- [ ] Build succeeds with no TypeScript errors
</verification>

<success_criteria>
- runScoring() function executes full scoring pipeline
- Score calculator uses policy weights correctly
- Recommendation consolidation removes duplicates and prioritizes critical
- Ladder optimizer generates valid modified ladder
- All components integrate correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoring-+-report/03-03-SUMMARY.md`
</output>
