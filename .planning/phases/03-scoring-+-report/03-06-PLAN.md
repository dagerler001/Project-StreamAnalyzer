---
phase: 03-scoring-+-report
plan: 06
type: execute
wave: 3
depends_on:
  - 03-03
  - 03-04
  - 03-05
files_modified:
  - src/report/components/ReportPanel.tsx
  - src/hooks/usePlaylistAnalysis.ts
  - src/App.tsx
  - src/App.css
autonomous: false

must_haves:
  truths:
    - "ReportPanel displays complete report with policy selector, score, breakdown, warnings, recommendations, and ladder comparison"
    - "Policy selector allows switching between Apple HLS, Google VP9, Generic"
    - "Hook provides score state and runScore action"
    - "App.tsx integrates ReportPanel into results section"
  artifacts:
    - path: "src/report/components/ReportPanel.tsx"
      provides: "Main report container component"
      exports: ["ReportPanel"]
    - path: "src/hooks/usePlaylistAnalysis.ts"
      provides: "Extended hook with scoring state and actions"
    - path: "src/App.tsx"
      provides: "Updated app with ReportPanel integration"
  key_links:
    - from: "ReportPanel"
      to: "src/scoring/engine/scoreEngine.ts"
      via: "runScoring call"
    - from: "ReportPanel"
      to: "src/scoring/policies/policyRegistry.ts"
      via: "getAllPolicies call"
    - from: "ReportPanel"
      to: "all report sub-components"
      via: "composition"
    - from: "usePlaylistAnalysis hook"
      to: "ReportPanel"
      via: "scoreState prop passing"
---

<objective>
Integrate the complete scoring and report system into the application.

Purpose: Wire together all Phase 3 components - add scoring state to the analysis hook, create the main ReportPanel container, and integrate it into App.tsx with policy selection and full report display.

Output: Fully functional Phase 3 application with working scoring, policy profiles, and on-screen report.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scoring-+-report/03-RESEARCH.md
@.planning/phases/03-03-SUMMARY.md
@.planning/phases/03-04-SUMMARY.md
@.planning/phases/03-05-SUMMARY.md
@src/hooks/usePlaylistAnalysis.ts
@src/App.tsx
@src/report/components/ScoreDisplay.tsx
@src/report/components/ScoreBreakdown.tsx
@src/report/components/WarningList.tsx
@src/report/components/RecommendationList.tsx
@src/report/components/LadderComparison.tsx
@src/scoring/engine/scoreEngine.ts
@src/scoring/policies/policyRegistry.ts
@src/components/SegmentedControl.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend analysis hook with scoring state</name>
  <files>src/hooks/usePlaylistAnalysis.ts</files>
  <action>
Extend the usePlaylistAnalysis hook to support scoring:

**Add to imports:**
- Import `ScoreResult`, `ScoringPolicy` from `../types/scoring`
- Import `runScoring` from `../scoring/engine/scoreEngine`
- Import `getAllPolicies` from `../scoring/policies/policyRegistry`

**Add new types:**
```typescript
type ScoreState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; result: ScoreResult }
  | { status: 'error'; error: string }
```

**Add to hook state:**
```typescript
const [scoreState, setScoreState] = useState<ScoreState>({ status: 'idle' })
const [selectedPolicy, setSelectedPolicy] = useState<string>('generic')
```

**Add to hook return value:**
```typescript
return {
  // ... existing values
  scoreState,
  selectedPolicy,
  setSelectedPolicy,
  runScoring: () => { ... },
}
```

**Implement runScoring action:**
```typescript
const runScoringAction = useCallback(() => {
  if (state.status !== 'success') return
  
  setScoreState({ status: 'loading' })
  
  try {
    const context: AnalysisContext = {
      ladder: state.result.ladder,
      classification: state.result.classification,
      sampleResult: sampleState.status === 'success' ? sampleState.result : undefined
    }
    
    const result = runScoring(context, selectedPolicy)
    setScoreState({ status: 'success', result })
  } catch (err) {
    setScoreState({ 
      status: 'error', 
      error: err instanceof Error ? err.message : 'Scoring failed' 
    })
  }
}, [state, sampleState, selectedPolicy])
```

**Auto-run scoring:**
When analysis completes successfully (state.status === 'success'), automatically trigger scoring if scoreState is idle.
  </action>
  <verify>npm run build compiles; hook exports new scoring properties</verify>
  <done>Hook extended with scoreState, selectedPolicy, setSelectedPolicy, runScoring</done>
</task>

<task type="auto">
  <name>Task 2: Create ReportPanel component</name>
  <files>src/report/components/ReportPanel.tsx</files>
  <action>
Create the main report panel component:

**Props interface:**
```typescript
interface ReportPanelProps {
  scoreState: ScoreState
  selectedPolicy: string
  availablePolicies: ScoringPolicy[]
  onPolicyChange: (policyId: string) => void
  onRunScoring: () => void
}
```

**Component structure:**
```tsx
export const ReportPanel = ({
  scoreState,
  selectedPolicy,
  availablePolicies,
  onPolicyChange,
  onRunScoring
}: ReportPanelProps) => {
  return (
    <div className="report-panel">
      {/* Policy Selector */}
      <section className="report-section">
        <h3>Scoring Policy</h3>
        <SegmentedControl
          options={availablePolicies.map(p => ({
            value: p.id,
            label: p.name
          }))}
          value={selectedPolicy}
          onChange={onPolicyChange}
        />
        <p className="policy-description">
          {availablePolicies.find(p => p.id === selectedPolicy)?.description}
        </p>
      </section>

      {/* Score Display */}
      {scoreState.status === 'success' && (
        <>
          <section className="report-section">
            <h3>Overall Score</h3>
            <ScoreDisplay score={scoreState.result.overall} />
          </section>

          <section className="report-section">
            <h3>Score Breakdown</h3>
            <ScoreBreakdown categories={Object.values(scoreState.result.categories)} />
          </section>

          <section className="report-section">
            <h3>Best Practice Warnings</h3>
            <WarningList warnings={scoreState.result.warnings} />
          </section>

          <section className="report-section">
            <h3>Recommendations</h3>
            <RecommendationList recommendations={scoreState.result.recommendations} />
          </section>

          <section className="report-section">
            <h3>Recommended Ladder</h3>
            <LadderComparison
              current={scoreState.result.originalLadder}
              recommended={scoreState.result.recommendedLadder}
            />
          </section>
        </>
      )}

      {scoreState.status === 'loading' && (
        <p className="placeholder">Calculating scores...</p>
      )}

      {scoreState.status === 'error' && (
        <div className="error-state">
          <p className="error-message">{scoreState.error}</p>
          <button onClick={onRunScoring} type="button">Retry</button>
        </div>
      )}
    </div>
  )
}
```

Import all sub-components from `./` and types from `../../types/scoring`, SegmentedControl from `../../components/SegmentedControl`.
  </action>
  <verify>npm run build compiles; component accepts all props</verify>
  <done>ReportPanel component created with all sections</done>
</task>

<task type="auto">
  <name>Task 3: Integrate ReportPanel into App.tsx and update styling</name>
  <files>
    src/App.tsx
    src/App.css
  </files>
  <action>
Integrate ReportPanel into the main app and add final styling:

**src/App.tsx changes:**

1. Update header to Phase 3:
   - Title: "Scoring + Report"
   - Subtitle: "Phase 3: Evaluate ABR ladders against best practices and get actionable recommendations."

2. Import ReportPanel:
   ```typescript
   import { ReportPanel } from './report/components/ReportPanel'
   import { getAllPolicies } from './scoring/policies/policyRegistry'
   ```

3. Destructure new hook values:
   ```typescript
   const {
     // ... existing
     scoreState,
     selectedPolicy,
     setSelectedPolicy,
     runScoring,
   } = usePlaylistAnalysis()
   ```

4. Add Report section after Sample Results:
   ```tsx
   <section className="results-section">
     <h3 className="results-section-title">Scoring Report</h3>
     <ReportPanel
       scoreState={scoreState}
       selectedPolicy={selectedPolicy}
       availablePolicies={getAllPolicies()}
       onPolicyChange={setSelectedPolicy}
       onRunScoring={runScoring}
     />
   </section>
   ```

**src/App.css additions:**

```css
/* Report Panel */
.report-panel {
  display: flex;
  flex-direction: column;
  gap: var(--space-6);
}

.report-section {
  background: var(--surface);
  border-radius: var(--radius-lg);
  padding: var(--space-4);
  border: 1px solid var(--border);
}

.report-section h3 {
  margin-top: 0;
  margin-bottom: var(--space-3);
  font-size: var(--text-lg);
  color: var(--text-primary);
}

.policy-description {
  margin-top: var(--space-3);
  font-size: var(--text-sm);
  color: var(--text-secondary);
}

/* Score Display */
.score-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-2);
}

.score-label {
  font-size: var(--text-lg);
  font-weight: 600;
}

/* Report-specific responsive */
@media (max-width: 768px) {
  .report-section {
    padding: var(--space-3);
  }
}
```
  </action>
  <verify>npm run build compiles; app starts without errors</verify>
  <done>App.tsx updated with ReportPanel, Phase 3 header, all styling added</done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Complete Phase 3 Scoring + Report feature including policy profiles, scoring engine, and on-screen report UI</what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Open http://localhost:5173 (or shown port)
    3. Verify header shows "Scoring + Report" and Phase 3 subtitle
    4. Ingest a test playlist (use URL, ID, or file from previous phases)
    5. Wait for analysis to complete
    6. Verify Report section appears with:
       - Policy selector (Apple HLS, Google VP9, Generic)
       - Overall score gauge
       - Score breakdown by category
       - Best practice warnings (if any)
       - Recommendations list (if any)
       - Ladder comparison (current vs recommended)
    7. Switch between policies and verify score recalculates
    8. Check that warnings and recommendations are explainable and actionable
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the report display</resume-signal>
</task>

</tasks>

<verification>
- [ ] Hook provides scoreState, selectedPolicy, setSelectedPolicy, runScoring
- [ ] ReportPanel renders all sections (policy selector, score, breakdown, warnings, recommendations, ladder comparison)
- [ ] App.tsx integrates ReportPanel and shows Phase 3 header
- [ ] Policy switching triggers score recalculation
- [ ] All report styling applied correctly
- [ ] Build succeeds with no TypeScript errors
- [ ] User verifies complete report functionality
</verification>

<success_criteria>
- Complete Phase 3 application with working scoring
- Policy profiles selectable and applied correctly
- Report shows score, breakdown, warnings, recommendations, ladder comparison
- UI matches existing design system
- All requirements (SCOR-01, SCOR-02, SCOR-03, REPT-01) satisfied
</success_criteria>

<output>
After completion and user approval, create `.planning/phases/03-scoring-+-report/03-06-SUMMARY.md`
</output>
