---
phase: 03-scoring-+-report
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/scoring/rules/ruleTypes.ts
  - src/scoring/rules/ladderRules.ts
  - src/scoring/rules/codecRules.ts
  - src/scoring/rules/segmentRules.ts
  - src/scoring/rules/index.ts
autonomous: true

must_haves:
  truths:
    - "Scoring rules exist for all 7 rule categories"
    - "Each rule returns normalized 0-100 score with explanations"
    - "Rules are exported via index.ts for engine consumption"
  artifacts:
    - path: "src/scoring/rules/ruleTypes.ts"
      provides: "Rule type definitions and rule registry type"
    - path: "src/scoring/rules/ladderRules.ts"
      provides: "Ladder-specific rules (bitrate-spacing, resolution-ladder)"
      exports: ["bitrateSpacingRule", "resolutionLadderRule"]
    - path: "src/scoring/rules/codecRules.ts"
      provides: "Codec rules (codec-compatibility, audio-codec)"
      exports: ["codecCompatibilityRule", "audioCodecRule"]
    - path: "src/scoring/rules/segmentRules.ts"
      provides: "Segment rules (segment-duration, keyframe-alignment, bandwidth-attributes)"
      exports: ["segmentDurationRule", "keyframeAlignmentRule", "bandwidthAttributesRule"]
    - path: "src/scoring/rules/index.ts"
      provides: "Rule registry mapping ruleId to ScoringRule"
      exports: ["getRuleById", "allRules"]
  key_links:
    - from: "src/scoring/rules/index.ts"
      to: "individual rule files"
      via: "imports"
    - from: "all rule files"
      to: "src/types/scoring.ts"
      via: "type imports"
---

<objective>
Implement the 7 scoring rules that evaluate ABR ladders against best practices using TDD.

Purpose: Create testable, explainable rules that produce scores (0-100) with clear warnings and recommendations. Rules cover: bitrate spacing, resolution ladder, codec compatibility, audio codec, segment duration, keyframe alignment, and bandwidth attributes.

Output: Complete rule implementations with passing tests for all 7 rules.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scoring-+-report/03-RESEARCH.md
@src/types/scoring.ts
@src/types/analysis.ts
</context>

<feature>
  <name>Scoring Rules Implementation</name>
  <files>
    src/scoring/rules/ruleTypes.ts
    src/scoring/rules/ladderRules.ts
    src/scoring/rules/codecRules.ts
    src/scoring/rules/segmentRules.ts
    src/scoring/rules/index.ts
  </files>
  
  <behavior>
    **Rule 1: bitrate-spacing**
    - Evaluates spacing between consecutive bitrate variants
    - Ideal step: 1.5x to 2x (industry standard)
    - Score 100 if all steps in range, partial for minor deviations, 0 for major issues
    - Recommendations: add_variant for gaps >3x, modify_variant for steps <1.3x
    
    **Rule 2: resolution-ladder**
    - Checks resolution progression matches bitrate progression
    - Validates standard resolutions present (240p, 360p, 480p, 720p, 1080p, 4K as appropriate)
    - Score based on completeness and proper ordering
    
    **Rule 3: codec-compatibility**
    - Evaluates codec choices for target platform
    - Apple policy: prefer H.264 baseline, H.265 for newer devices
    - Google policy: prefer VP9 where supported
    - Generic: H.264 as safe default
    
    **Rule 4: audio-codec**
    - Validates audio codec choices (AAC standard)
    - Checks audio-only variant presence for low-bandwidth scenarios
    
    **Rule 5: segment-duration**
    - Validates segment duration is within recommended range (2-10 seconds typical)
    - Live streams: shorter segments (2-6s) preferred
    - VOD: longer segments (6-10s) acceptable
    
    **Rule 6: keyframe-alignment**
    - Checks keyframe alignment across variants (important for switching)
    - Validates keyframe interval is reasonable (1-4 seconds)
    
    **Rule 7: bandwidth-attributes**
    - Validates BANDWIDTH and AVERAGE-BANDWIDTH attributes present
    - Checks values are reasonable and consistent
  </behavior>
  
  <implementation>
    **File Structure:**
    - `ruleTypes.ts`: ScoringRule interface, rule registry type
    - `ladderRules.ts`: bitrateSpacingRule, resolutionLadderRule
    - `codecRules.ts`: codecCompatibilityRule, audioCodecRule  
    - `segmentRules.ts`: segmentDurationRule, keyframeAlignmentRule, bandwidthAttributesRule
    - `index.ts`: getRuleById(id) function, allRules array
    
    **Rule Implementation Pattern:**
    Each rule is a ScoringRule object with:
    - id, name, category
    - check(context): RuleResult function
    
    **Test Cases per Rule:**
    1. Perfect ladder → score 100, no warnings
    2. Minor issues → score 60-80, warnings, recommendations
    3. Major issues → score 0-40, errors, critical recommendations
    4. Edge cases (empty ladder, single variant) → graceful handling
    
    **RED Phase:** Write test file with cases, run tests (must fail)
    **GREEN Phase:** Implement minimal rule logic to pass tests
    **REFACTOR Phase:** Clean up if needed, ensure all tests pass
  </implementation>
</feature>

<verification>
- [ ] All 7 rules implemented with check functions
- [ ] Rule registry (index.ts) exports getRuleById and allRules
- [ ] Each rule returns RuleResult with score (0-100), warnings, recommendations
- [ ] Tests pass for all rules (perfect, minor issues, major issues, edge cases)
- [ ] Build succeeds with no TypeScript errors
</verification>

<success_criteria>
- 7 scoring rules implemented and tested
- Rule registry provides access by ID
- All rules return normalized scores with explanations
- Test coverage for happy path and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoring-+-report/03-02-SUMMARY.md`

Commits expected:
- test(03-02): add failing tests for scoring rules
- feat(03-02): implement scoring rules
</output>
