---
phase: 02-sampling-+-metrics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/analysis.ts
  - src/analysis/sampling/analyzeSample.ts
  - src/analysis/sampling/sampleWindow.ts
  - src/analysis/sampling/segmentProbe.ts
autonomous: true

must_haves:
  truths:
    - "User can sample a time window and receive bitrate-over-time results."
    - "User can see codec information derived from playlist attributes or probe data."
    - "Sampling returns partial results with warnings when headers or probes fail."
  artifacts:
    - path: "src/analysis/sampling/analyzeSample.ts"
      provides: "End-to-end sample analysis with variant selection and diagnostics"
    - path: "src/analysis/sampling/sampleWindow.ts"
      provides: "Segment timeline and window selection helpers"
    - path: "src/types/analysis.ts"
      provides: "SampleConfig and SampleResult domain types"
  key_links:
    - from: "src/analysis/sampling/analyzeSample.ts"
      to: "src/analysis/playlist/parseM3U8.ts"
      via: "parseM3U8 for variant playlist"
      pattern: "parseM3U8"
    - from: "src/analysis/sampling/analyzeSample.ts"
      to: "src/analysis/sampling/sampleWindow.ts"
      via: "window selection helper"
      pattern: "sampleWindow"
    - from: "src/analysis/sampling/analyzeSample.ts"
      to: "src/analysis/sampling/segmentProbe.ts"
      via: "codec/size probing"
      pattern: "segmentProbe"
---

<objective>
Build sampling analysis primitives to compute sample windows, codecs, and bitrate series from playlist segments.

Purpose: Establish the Phase 2 analysis core used by UI sampling controls and charts.
Output: Sampling types plus reusable helpers that probe segment sizes and compute metrics.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sampling-+-metrics/02-RESEARCH.md
@src/types/analysis.ts
@src/analysis/playlist/parseM3U8.ts
@src/analysis/ladder/codecLabels.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define sampling domain types</name>
  <files>src/types/analysis.ts</files>
  <action>
Add Phase 2 sampling types without changing existing Phase 1 types. Include:
- SampleConfig with durationSeconds, optional startOffsetSeconds (VOD), optional liveAnchorSeconds (live), and selectedRenditionIndex.
- SampleWindow with startSeconds, endSeconds, actualDurationSeconds, and requestedDurationSeconds.
- BitratePoint with segmentIndex, startSeconds, durationSeconds, bytes, bitrateBps, and rollingAverageBps.
- SampleCodecs with video/audio arrays for both friendly labels and raw codec strings.
- SampleDiagnostics with warnings, errors, missingHeaders, and segmentCount.
- SampleResult with window, bitrateSeries (points), codecs, diagnostics, and reliable flag.

Keep all fields optional only when required for partial results; prefer explicit undefined instead of null.
  </action>
  <verify>npm run build</verify>
  <done>Sampling types compile and are ready for analysis helpers and UI consumption.</done>
</task>

<task type="auto">
  <name>Task 2: Implement sampling + probing helpers</name>
  <files>
src/analysis/sampling/analyzeSample.ts
src/analysis/sampling/sampleWindow.ts
src/analysis/sampling/segmentProbe.ts
  </files>
  <action>
Create a sampling module that can analyze either media or master playlists:
- sampleWindow.ts: build a cumulative segment timeline from manifest.segments, then select segments overlapping a window. For VOD use startOffsetSeconds; for live compute window end as (totalDuration - liveAnchorSeconds), then start = end - durationSeconds. Clamp bounds and return a SampleWindow + selected segments.
- segmentProbe.ts: issue HEAD requests for each segment URL to read Content-Length or Content-Range. Convert bytes and duration into bitrateBps. If headers are missing or CORS blocks the request, skip that point and record diagnostics. Do not download full segments.
- segmentProbe.ts: add an optional lightweight codec probe when CODECS is missing by issuing a ranged GET (0-2047 bytes) against the first media segment or EXT-X-MAP init segment (if present). Parse MP4 `ftyp`/`moov` boxes for codec hints when possible; otherwise fall back to Content-Type heuristics (e.g., video/mp4 -> h264/aac, video/mp2t -> h264/aac). Record diagnostics when probe fails.
- analyzeSample.ts: accept parsed manifest, basePlaylistUrl (optional), SampleConfig, and selected rendition index. If manifest is master, resolve the selected variant URI against basePlaylistUrl, fetch and parse it via parseM3U8. Extract codecs from playlist attributes (CODECS) using getCodecLabels for friendly names; if missing, call the codec probe and populate SampleCodecs with a warning/diagnostic. Assemble SampleResult with rolling average (3-point window) and reliable=false when any diagnostics/errors exist.

Do not add new dependencies. Use new URL(uri, baseUrl) for URL resolution and keep all networking in fetch.
  </action>
  <verify>npm run build</verify>
  <done>Sample analysis returns bitrate points, codec info, and diagnostics for both master and media playlists.</done>
</task>

</tasks>

<verification>
npm run build
</verification>

<success_criteria>
- Sampling helpers compute a window and bitrate series from segment headers.
- Codec detection prefers playlist CODECS and records missing data as diagnostics.
- Analysis produces partial results when probing fails instead of throwing.
</success_criteria>

<output>
After completion, create `.planning/phases/02-sampling-+-metrics/02-01-SUMMARY.md`
</output>
